{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>Welcome to the QAL Workshop!</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Setup</li> <li>Introduction</li> <li>Example - Grover's Algorithm</li> <li>Hands-on - Grover's Algorithm with CLI</li> </ul>"},{"location":"grover-cli/","title":"Second Example - Grover with CLI","text":"<p>We extended the previous example, so instead of hardcoded  parameters, it will run according to user input.</p> <p>Here, the focus is to observe the outcome resulting from modifying  different parameters, such as the oracle definition and the  constraints.</p>"},{"location":"grover-cli/#cli-syntax","title":"CLI Syntax","text":"<p>The CLI syntax is given as follows:</p> <ol> <li><code>oracle</code> - required: an arithmetic oracle expression and the     variable declarations. <ul> <li>Example: <code>--oracle \"a + b == 11 and (a - b == 1 or b - a == 1)\" a 3 b 3</code>. </li> </ul> </li> <li><code>iterations</code> - the number of Grover iterations. Default: <code>1</code>.</li> <li><code>optimization-parameter</code> - a quantitative parameter provided     to the synthesis engine to optimize the circuit by. Can get the     following arguments: <ul> <li><code>width</code> - Total number of qubits. Prefers implementations     with a minimal number of qubits and reusing released qubits     instead of allocating new ones.</li> <li><code>depth</code> - Circuit depth. Prefers implementations with a higher     number of qubits and will avoid reusing qubits.</li> <li><code>cx</code> - CX gate count. Prefers implementations with a higher     number of qubits and does not care about qubit reuse.  It is recommended to optimize by width when performing     sampling.</li> <li>Example: <code>--optimization-parameter width</code></li> </ul> </li> <li><code>max-width</code>, <code>max-depth</code>, <code>max-cx-count</code> - numerical     limitations on the quantities.<ul> <li>Example: <code>--max-width 14</code></li> </ul> </li> <li><code>sample-circuit</code> - a flag that gets <code>true</code> (default) or <code>false</code>.     It is recommended to avoid sampling if not optimizing by     width.</li> <li><code>visualize-circuit</code> - a flag that gets <code>true</code> (default) or <code>false</code>.</li> </ol>"},{"location":"grover-cli/#suggested-exercises","title":"Suggested Exercises","text":"<ol> <li>Try sampling different oracles - vary the arithmetic     expressions, variable sizes, and the number of variables.     - Note: currently, the variables are unsigned integers only.</li> <li>Try spotting the diffuser and isolating the block that belongs     to the multi-controlled Z operation (currently, it's not marked     explicitly, but it will be in the future).</li> <li>Pick an oracle of size at least 8. Here, size refers to the     total sum of the registers of the variables. Optimize the CX     gate count and visualize the circuit. What is the resulting     number of qubits? How many qubits does the multi-controlled Z gate have?</li> <li>Repeat the process, but now optimize the width.</li> <li>Try limiting the gate-count to a ridiculously small number (e.g.    , 1). What is the resulting error message?</li> </ol>"},{"location":"grover-example/","title":"First Example - Grover","text":"<p>For a Grover example in Cuda Quantum, see  Cuda Quantum documentation.</p> <p>The first part focuses on constructing a simple example of  Grover's algorithm with an arithmetic oracle. Here, the goal is  to present Classiq's built-in library and show kernel  visualization. </p> <p>The next session will discuss constraints in detail.</p> <p>In this example, we provide a hardcoded circuit as follows:</p> <ol> <li>The oracle is the following arithmetic expression <code>a + b == 5     and a - b == 1</code>, where <code>a</code> and <code>b</code> are unsigned integers.     This, of course, evaluates to <code>a = 3</code> and <code>b = 2</code>.</li> <li>We perform a single iteration.</li> <li>The state preparation is a uniform superposition (default).</li> </ol> <p>Before we run the example, let's break down its different parts. </p>"},{"location":"grover-example/#the-oracle","title":"The Oracle","text":"<p>The oracle performs the transformation</p> \\[ \\sum_{x=\\left\\{0,1\\right\\}^{n}}\\psi_{x}\\left|x\\right&gt; \\rightarrow \\sum_{x=\\left\\{0,1\\right\\}^{n}}\\psi_{x}\\left(-1\\right)^{f\\left(x\\right)} \\left|x\\right&gt; \\] <p>Where, usually, the coefficients \\(\\psi_{x}\\) are uniform, so \\(\\psi_ {x} = \\frac{1}{\\sqrt{2^{n}}\\).</p> <p>Here, we use an arithmetic oracle, so \\(f\\left(x\\right) = 1\\) for  \\(x\\) that satisfies some arithmetic condition. </p> <p>Note that the arithmetic oracle is a Classiq built-in function that  automatically generates the corresponding unitary operator. The  function gets variable declarations and an arithmetic expression  as arguments.</p> <pre><code>   auto my_oracle = classiq::arithmetic_oracle(\n{\nclassiq::arithmetic_register{\"a\", 2}, classiq::arithmetic_register{\"b\", 2}\n},\n\"(a + b == 5) and (a - b == 1)\"\n);\n</code></pre>"},{"location":"grover-example/#the-diffuser-second-reflection","title":"The Diffuser (Second Reflection)","text":"<p>The Grover's diffuser \"reflects\" around a chosen quantum state  \\(\\left|\\psi\\right&gt;\\),  usually the uniform superposition state, </p> \\[  \\left|\\psi\\right&gt; = \\frac{1}{\\sqrt{2^{n}}}\\sum_ {x=\\left\\{0,1\\right\\}^{n}}\\left|x\\right&gt;, \\] <p>initialized by applying  Hadamard gates on all qubits by applying the transformation  \\(2\\left|\\psi\\right&gt;\\left&lt;\\psi\\right| - \\mathbf{I}\\).</p>"},{"location":"grover-example/#the-state-preparation","title":"The State Preparation","text":"<p>In this code, let's focus on the last line: it shows the internal  Classiq's <code>apply_to_all</code> construct.</p> <pre><code>    auto my_state_preparation = classiq::make_qfunc(\n\"my_state_preparation\",\n[](classiq::qreg&lt;\"target\"&gt; qreg)\n{ classiq::apply_to_all(qreg.size(), classiq::h, qreg); }\n);\n</code></pre>"},{"location":"grover-example/#the-full-diffuser","title":"The Full Diffuser","text":"<p>The diffuser gets a state preparation as an argument, so it can  reflect about states other than the uniform superposition. Here, we meet two additional constructs: <code>control</code> and <code>invert</code>.</p> <p>The main focus here is on the last three statements.</p> <pre><code>    auto compute_block = classiq::make_qfunc(\n\"compute_block\",\n[](\nclassiq::qreg&lt;\"block\"&gt; qreg,\nclassiq::operand&lt;\"state_preparation\", classiq::qreg&lt;\"target\"&gt;&gt; state_preparation\n)\n{\nclassiq::apply_to_all(qreg.size(), classiq::x, qreg);\nstate_preparation(qreg);\n}\n);\n\nauto my_diffuser = classiq::make_qfunc(\n\"my_diffuser\",\n[&amp;compute_block](\nclassiq::qreg&lt;\"diff\"&gt; diffuser_qreg,\nclassiq::operand&lt;\"state_preparation\", classiq::qreg&lt;\"target\"&gt;&gt; state_preparation\n)\n{\nclassiq::invert(diffuser_qreg, [&amp;](classiq::qreg&lt;\"target\"&gt; q) { compute_block(q, state_preparation); });\nclassiq::control(diffuser_qreg.back(), diffuser_qreg.front(diffuser_qreg.size() - 1), classiq::z);\ncompute_block(diffuser_qreg, state_preparation);\n}\n);\n</code></pre>"},{"location":"grover-example/#the-grover-search-putting-everything-together","title":"The Grover Search - Putting Everything Together","text":"<p>Here, we meet the construct <code>repeat</code> that concatenates the Grover  operators according to the number of repetitions provided by the  user. </p> <p>Note: </p> <ol> <li><code>apply_to_all</code> is a special case of <code>repeat</code>.</li> <li><code>my_diffuser</code> is an external function captured by the grover     search (by using <code>[&amp;my_diffuser]</code>). The state preparation     operand is propagated to the diffuser.</li> </ol> <pre><code>   auto grover_search = classiq::make_qfunc(\n\"my_grover_search\",\n[&amp;my_diffuser](\nclassiq::param&lt;\"reps\", size_t&gt; reps,\nclassiq::qreg&lt;\"grover\"&gt; qreg,\nclassiq::operand&lt;\"state_preparation\", classiq::qreg&lt;\"target\"&gt;&gt; state_preparation,\nclassiq::operand&lt;\"oracle\", classiq::qreg&lt;\"oracle\"&gt;&gt; oracle\n)\n{\nstate_preparation(qreg);\nclassiq::repeat(\nqreg,\nreps,\n[&amp;](classiq::param&lt;\"index\", size_t&gt;, classiq::qreg&lt;\"qbv\"&gt; q)\n{\noracle(q);\nmy_diffuser(q, state_preparation);\n}\n);\n}\n);\n</code></pre>"},{"location":"grover-example/#the-entry-point","title":"The Entry Point","text":"<p>The entry point calls the Grover search.  By using <code>[&amp;]</code>, we capture the previously defined functions  <code>my_state_preparation</code> and <code>my_oracle_op</code> into the call. Here, we  perform a single Grover iteration.</p> <pre><code>    auto main = classiq::make_qfunc(\n\"main\",\n[&amp;]()\n{\nauto all_qubits = classiq::allocate&lt;\"grover\"&gt;(my_oracle.size());\ngrover_search(1, all_qubits, my_state_preparation, my_oracle_op);\n}\n);\n</code></pre>"},{"location":"grover-example/#executing-the-flow","title":"Executing the Flow","text":"<p>Now, we construct the model, call the Classiq synthesis  engine, run the synthesized circuit, and visualize it:</p> <pre><code>auto model = classiq::model(main);\nauto [kernel, qubit_mapping] = classiq::synthesize(model);\n\nauto counts = cudaq::sample(kernel);\ncounts.dump();\n\nclassiq::visualize(kernel);\n</code></pre>"},{"location":"grover-example/#add-instructions-to-run-the-code","title":"Add instructions to run the code","text":""},{"location":"introduction/","title":"Introduction","text":"<p>The workshop will present the integration between Cuda Quantum and  Classiq.</p> <ol> <li>Program with Classiq (in a fashion of Cuda Quantum)</li> <li>Synthesize the circuit with Classiq</li> <li>Output a Cuda Quantum kernel</li> <li>Execute the kernel in Cuda Quantum</li> <li>Visualize the kernel using Classiq</li> </ol> <p>The end goal - a uniform framework where users program in Cuda  Quantum and benefit from Classiq's enhancements:</p> <ul> <li>Utilize algorithmic information above gate level to reduce    circuit operations</li> <li>Releasing and reallocating qubits</li> <li>Selecting between equivalent implementations</li> </ul> <p>The framework will combine the Cuda Quantum programming model,  compilation, and execution with Classiq library, synthesis, and  visualization: Step 1 will be replaced by programming with Cuda  Quantum.</p> <p>Therefore, the workshop will focus on Classiq's library, synthesis  and visualization and less on the programming. </p>"},{"location":"prerequisites/","title":"Prerequisites","text":""},{"location":"setup/","title":"Setup","text":"<p>Please perform the following steps below before the workshop:</p>"},{"location":"setup/#registration-to-classiq-platform","title":"Registration to Classiq Platform","text":"<ol> <li>Register to Classiq.</li> </ol>"},{"location":"setup/#visual-studio-code-and-extensions","title":"Visual Studio Code and Extensions","text":"<ol> <li> <p>Make sure to have Python installed.</p> </li> <li> <p>Download the Python script setup_remote.py</p> </li> <li> <p>Run <code>setup_remote.py gpu-name user-name</code>, the last two fields     will be provided at the workshop.</p> </li> <li> <p>Install Visual Studio Code and     open a new window.</p> </li> <li>Install Remote Development Extension Pack (see image below).</li> <li>Press Ctrl + Shift + P (or CMD + Shift + P in Mac) and     choose <code>Remote-SSH: Connect to Host\u2026</code></li> <li>Choose <code>qal-workshop~host</code></li> <li>Install the following extensions : C/C++ Extension Pack and CMake     Tools.</li> </ol> <p></p>"},{"location":"setup/#workshop-files","title":"Workshop Files","text":"<ol> <li>In your project, open a folder named <code>qal-workshop</code>.</li> <li>Download the following files. Keep the folder structure as     shown.</li> </ol> <p>qal-workshop \u251c\u2500CMakeLists.txt \u251c\u2500include \u2502 \u251c\u2500grover_cli_tools.hpp \u251c\u2500src \u2502 \u251c\u2500grover_cli_tools.cpp \u2502 \u251c\u2500grover_example.cpp \u2502 \u251c\u2500grover_cli.cpp </p>"}]}