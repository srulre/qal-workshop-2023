{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QAL Workshop 2023","text":"<p>Welcome to the QAL Workshop October 2023!</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Setup</li> <li>Introduction</li> <li>Example - Grover's Algorithm</li> <li>Hands-on - Grover's Algorithm with CLI</li> </ul>"},{"location":"grover-cli/","title":"Second Example - Grover with CLI","text":"<p>We extended the previous example, so instead of hardcoded  parameters, it will run according to user input.</p> <p>Here, the focus is to observe the outcome resulting from modifying  different parameters, such as the oracle definition and the  constraints.</p>"},{"location":"grover-cli/#cli-syntax","title":"CLI Syntax","text":"<p>The CLI syntax is given as follows:</p> <ol> <li><code>oracle</code> - required: an arithmetic oracle expression and the     variable declarations.<ul> <li>For the list of supported arithmetic operators, see Classiq     documentation on arithmetic expressions.</li> <li>Example: <code>--oracle \"a + b == 11 and (a - b == 1 or b - a == 1)\" a 3 b 3</code>.</li> <li>Note: currently, the variables are unsigned integers only.</li> </ul> </li> <li><code>iterations</code> - the number of Grover iterations. Default: <code>1</code>.</li> <li><code>optimization-parameter</code> - a quantitative parameter provided     to the synthesis engine to optimize the circuit by. Can get the     following arguments: <ul> <li><code>width</code> - Total number of qubits. Prefers implementations     with a minimal number of qubits and reusing released qubits     instead of allocating new ones.</li> <li><code>depth</code> - Circuit depth. Prefers implementations with a higher     number of qubits and will avoid reusing qubits.</li> <li><code>cx</code> - CX gate count. Prefers implementations with a higher     number of qubits and does not care about qubit reuse.  It is recommended to optimize by width when performing     sampling.</li> <li>Example: <code>--optimization-parameter width</code></li> </ul> </li> <li><code>max-width</code>, <code>max-depth</code>, <code>max-cx-count</code> - numerical     limitations on the quantities.<ul> <li>Example: <code>--max-width 14</code></li> </ul> </li> <li><code>sample-circuit</code> - a flag that gets <code>true</code> (default) or <code>false</code>.     It is recommended to avoid sampling if not optimizing by     width.</li> <li><code>visualize-circuit</code> - a flag that gets <code>true</code> (default) or <code>false</code>.</li> </ol>"},{"location":"grover-cli/#running-the-code","title":"Running the Code","text":"<p>In the Visual Studio Code terminal, inside the <code>qal_workshop</code>  folder, run <code>./build/grover_cli --oracle ORACLE [optional args]</code>.</p>"},{"location":"grover-cli/#suggested-exercises","title":"Suggested Exercises","text":"<ol> <li>Try sampling different oracles - vary the arithmetic     expressions, variable sizes, and the number of variables.</li> <li>Try spotting the diffuser and isolating the block that belongs     to the multi-controlled Z operation (currently, it's not marked     explicitly, but it will be in the future).</li> <li>Pick an oracle of size at least 8. Here, size refers to the     total sum of the registers of the variables. Optimize the CX     gate count and visualize the circuit. What is the resulting     number of qubits? How many qubits does the multi-controlled Z gate have?</li> <li>Repeat the process, but now optimize the width.</li> <li>Try limiting the gate-count to a ridiculously small number (e.g.    , 1). What is the resulting error message?</li> </ol>"},{"location":"grover-example/","title":"First Example - Grover","text":"<p>For a Grover example in CUDA Quantum, see  CUDA Quantum documentation.</p> <p>The first part focuses on constructing a simple example of  Grover's algorithm with an arithmetic oracle. Here, the goal is  to present Classiq's built-in library and show CUDA kernel  visualization. </p> <p>The next session will discuss constraints in detail.</p> <p>In this example, we provide a hardcoded circuit as follows:</p> <ol> <li>The oracle is the following arithmetic expression <code>a + b == 5     and a - b == 1</code>, where <code>a</code> and <code>b</code> are unsigned integers.     This, of course, evaluates to <code>a = 3</code> and <code>b = 2</code>.</li> <li>We perform a single iteration.</li> <li>The state preparation is a uniform superposition (default).</li> </ol> <p>Before we run the example, let's break down its different parts. </p>"},{"location":"grover-example/#the-oracle","title":"The Oracle","text":"<p>A computational basis oracle performs the transformation</p> \\[ \\left|\\psi\\right&gt; = \\sum_{x=\\left\\{0,1\\right\\}^{n}}\\psi_{x} \\left|x\\right&gt; \\rightarrow \\sum_{x=\\left\\{0,1\\right\\}^{n}}\\psi_{x}\\left(-1\\right)^{f\\left(x\\right)} \\left|x\\right&gt; \\] <p>In the canonical Grover algorithm, the coefficients \\(\\psi_{x}\\) are  uniform, so</p> \\[  \\left|\\psi\\right&gt; = \\frac{1}{\\sqrt{2^{n}}}\\sum_ {x=\\left\\{0,1\\right\\}^{n}}\\left|x\\right&gt;, \\] <p>Here, we use an arithmetic oracle, so \\(f\\left(x\\right) = 1\\) for  \\(x\\) that satisfies some arithmetic condition. </p> <p>Note that the arithmetic oracle is a Classiq built-in function that  automatically generates the corresponding unitary operator. The  function gets variable declarations and an arithmetic expression  as arguments.</p> <pre><code>   auto my_oracle = classiq::arithmetic_oracle(\n{\nclassiq::arithmetic_register{\"a\", 2}, classiq::arithmetic_register{\"b\", 2}\n},\n\"(a + b == 5) and (a - b == 1)\"\n);\n</code></pre>"},{"location":"grover-example/#the-diffuser","title":"The Diffuser","text":"<p>The Grover's diffuser \"reflects\" around a chosen quantum state  \\(\\left|\\psi\\right&gt;\\), by applying the operator \\(2\\left|\\psi\\right&gt;\\left&lt;\\psi\\right| - \\mathbf{I}\\).</p>"},{"location":"grover-example/#the-state-preparation","title":"The State Preparation","text":"<p>The state preparation is a unitary operator that performs the  transformation \\(\\left|0\\right&gt; \\rightarrow \\left|\\psi\\right&gt;\\).</p> <p>Here, we show the canonical example, where the uniform  superposition state is obtained by applying Hadamard gates on all  qubits.</p> <p>In this code, let's focus on the last line: it shows the internal Classiq's <code>apply_to_all</code> construct.</p> <pre><code>    auto my_state_preparation = classiq::make_qfunc(\n\"my_state_preparation\",\n[](classiq::qreg&lt;\"target\"&gt; qreg)\n{ classiq::apply_to_all(qreg.size(), classiq::h, qreg); }\n);\n</code></pre>"},{"location":"grover-example/#the-full-diffuser","title":"The Full Diffuser","text":"<p>The diffuser gets a state preparation as an argument, so it can  reflect about states other than the uniform superposition. Here, we meet two additional constructs: <code>control</code> and <code>invert</code>.</p> <p>The main focus here is on the last three statements.</p> <pre><code>    auto compute_block = classiq::make_qfunc(\n\"compute_block\",\n[](\nclassiq::qreg&lt;\"block\"&gt; qreg,\nclassiq::operand&lt;\"state_preparation\", classiq::qreg&lt;\"target\"&gt;&gt; state_preparation\n)\n{\nclassiq::apply_to_all(qreg.size(), classiq::x, qreg);\nstate_preparation(qreg);\n}\n);\n\nauto my_diffuser = classiq::make_qfunc(\n\"my_diffuser\",\n[&amp;compute_block](\nclassiq::qreg&lt;\"diff\"&gt; diffuser_qreg,\nclassiq::operand&lt;\"state_preparation\", classiq::qreg&lt;\"target\"&gt;&gt; state_preparation\n)\n{\nclassiq::invert(\ndiffuser_qreg, [&amp;](classiq::qreg&lt;\"target\"&gt; q) { compute_block(q, state_preparation); }\n);\nclassiq::control(\ndiffuser_qreg.back(), diffuser_qreg.front(diffuser_qreg.size() - 1), classiq::z\n);\ncompute_block(diffuser_qreg, state_preparation);\n}\n);\n</code></pre>"},{"location":"grover-example/#the-grover-search-putting-everything-together","title":"The Grover Search - Putting Everything Together","text":"<p>Here, we meet the construct <code>repeat</code> that concatenates the Grover  operators according to the number of repetitions provided by the  user. </p> <p>Note: </p> <ol> <li><code>apply_to_all</code> is a special case of <code>repeat</code>.</li> <li><code>my_diffuser</code> is an external function captured by the grover     search (by using <code>[&amp;my_diffuser]</code>). The state preparation     operand is propagated to the diffuser.</li> </ol> <pre><code>   auto grover_search = classiq::make_qfunc(\n\"my_grover_search\",\n[&amp;my_diffuser](\nclassiq::param&lt;\"reps\", size_t&gt; reps,\nclassiq::qreg&lt;\"grover\"&gt; qreg,\nclassiq::operand&lt;\"state_preparation\", classiq::qreg&lt;\"target\"&gt;&gt; state_preparation,\nclassiq::operand&lt;\"oracle\", classiq::qreg&lt;\"oracle\"&gt;&gt; oracle\n)\n{\nstate_preparation(qreg);\nclassiq::repeat(\nqreg,\nreps,\n[&amp;](classiq::param&lt;\"index\", size_t&gt;, classiq::qreg&lt;\"qbv\"&gt; q)\n{\noracle(q);\nmy_diffuser(q, state_preparation);\n}\n);\n}\n);\n</code></pre>"},{"location":"grover-example/#the-entry-point","title":"The Entry Point","text":"<p>The entry point calls the Grover search.  By using <code>[&amp;]</code>, we capture the previously defined functions  <code>my_state_preparation</code> and <code>my_oracle_op</code> into the call. Here, we  perform a single Grover iteration.</p> <pre><code>    auto main = classiq::make_qfunc(\n\"main\",\n[&amp;]()\n{\nauto all_qubits = classiq::allocate&lt;\"grover\"&gt;(my_oracle.size());\ngrover_search(1, all_qubits, my_state_preparation, my_oracle_op);\n}\n);\n</code></pre>"},{"location":"grover-example/#executing-the-flow","title":"Executing the Flow","text":"<p>Now, we construct the model, call the Classiq synthesis  engine, run the synthesized circuit, and visualize it:</p> <pre><code>auto model = classiq::model(main);\nauto [kernel, qubit_mapping] = classiq::synthesize(model);\n\nauto counts = cudaq::sample(kernel);\ncounts.dump();\n\nclassiq::visualize(kernel);\n</code></pre>"},{"location":"grover-example/#running-the-code","title":"Running the Code","text":"<p>In the Visual Studio Code terminal, inside the <code>qal_workshop</code>  folder, run <code>./build/grover_example</code>.</p>"},{"location":"introduction/","title":"Introduction","text":"<p>The workshop will present the integration between CUDA Quantum and  Classiq.</p> <ol> <li>Program with Classiq (in the fashion of CUDA Quantum)</li> <li>Synthesize the circuit with Classiq</li> <li>Output a CUDA Quantum kernel</li> <li>Execute the kernel in CUDA Quantum</li> <li>Visualize the kernel using Classiq</li> </ol> <p>The end goal - a uniform framework where users program in CUDA  Quantum and benefit from Classiq's enhancements:</p> <ul> <li>Utilize algorithmic information above gate level to reduce    circuit operations</li> <li>Releasing and reallocating qubits</li> <li>Selecting between equivalent implementations based on    optimization criteria</li> </ul> <p>The framework will combine the CUDA Quantum programming model,  compilation, and execution with Classiq library, synthesis, and  visualization.</p> <p>Therefore, the workshop will focus on Classiq's library, synthesis  and visualization and less on the syntax. </p>"},{"location":"prerequisites/","title":"Prerequisites","text":""},{"location":"setup/","title":"Setup","text":"<p>Please perform the steps below:</p>"},{"location":"setup/#registration-to-classiq-platform","title":"Registration to Classiq Platform","text":"<ol> <li>Register to Classiq.</li> </ol>"},{"location":"setup/#visual-studio-code-and-extensions","title":"Visual Studio Code and Extensions","text":"<ol> <li>Make sure to have Python installed.</li> <li>Install Visual Studio Code and     open a new window.</li> </ol>"},{"location":"setup/#setting-up-the-ssh-connection","title":"Setting up the SSH Connection:","text":"<ol> <li>Download the Python script (also available in <code>JHS_notebooks</code>)     setup_remote.py     and run <code>setup_remote USER-NAME</code>.</li> <li>Install Remote Development Extension Pack (see image below).</li> </ol>"},{"location":"setup/#connecting","title":"Connecting:","text":"<ol> <li>Press Ctrl+Shift+P (or CMD+Shift+P in Mac) and     choose <code>Remote-SSH: Connect to Host\u2026</code>.</li> <li>Choose <code>qal-workshop~host</code>.</li> </ol>"},{"location":"setup/#finalizing","title":"Finalizing:","text":"<ol> <li>Install the following extensions : C/C++ Extension Pack and CMake     Tools.</li> </ol>"},{"location":"setup/#workshop-files","title":"Workshop Files","text":"<ol> <li>From the JHS Notebooks, copy the files inside the     <code>qal_workshop</code> folder to the Apptainer: <code>cp -r     ~/JHS_notebooks/qal_workshop ~/qal_workshop</code>.</li> </ol>"},{"location":"setup/#building-the-project","title":"Building the Project","text":"<ol> <li>Open the <code>qal_workshop</code> folder in the VSCode.</li> <li>Press Ctrl+Shift+P (CMD+Shift+P) and choose <code>CMake:     Configure</code>.</li> <li>Press Ctrl+Shift+P (CMD+Shift+P) and choose <code>CMake:     Build</code>.</li> </ol>"},{"location":"setup/#authentication","title":"Authentication","text":"<p>We need the generated access token to call the Classiq API and run  the examples.</p> <ol> <li>Option 1 - automatic: Run     <code>JHS_notebooks/generate_access_token_for_cudaq.py</code>.    Make sure the file <code>~/classiq_token.txt</code> has been created.</li> <li>Option 2 - manual: Run the authentication script     <code>export_classiq_token</code> located in the <code>JHS_notebook</code> folder.     Copy the token contents to <code>~/classiq_token.txt</code>.</li> </ol>"}]}